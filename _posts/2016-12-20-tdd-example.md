---
layout: post
title: Как я начал использовать TDD.
---

Я представлял TDD следующим образом: садишься, много думаешь над тем что надо сделать, придумываешь тесты, пишешь их, и потом пишешь код. Разработка готова. Этот подход я не использовал, так как сесть и написать сразу все тесты и поведение я не в состоянии. 

Потом я прочитал Кента Бэка (Kent Beck, Test-Driven Development: By Example.) и понял, что все вообще по-другому. Пишется один минимальный тест, имплементируется, потом еще тест, потом код и так далее пока не будет описано все поведение. Постоянно идет непрерывный процесс красный-зеленый-рефакторинг. Тесты тоже переписываются, движение идет небольшими итерациями.

> TDD заставляет думать о том, как должна работать доменная модель, а не как ее реализовать

Вернемся на шаг назад. Как я писал до этого. Продумываешь реализацию, пишешь код, много кода. Потом делаешь тесты на что получилось и отправляешь в продакшен. Код немного поправляется, чтобы сделать его тестируемым. Но преобладают интеграционные тесты, так как код сильно связанный.

Вот пример: делаю атрибуты для продуктов. Как сделать это в старом подходе: 

* подумаем как это хранить
* создадим таблицы 
* сделаем миграции
* накрутим сверху entity
* потом dao
* заделаем сервисов 
* и контроллеров еще. 

Где-то с dao начинаю писать тесты, но в реальности тесты появятся после контроллеров. В итоге куча кода написана до тестов и что-то менять уже некогда и дорого, надо ехать в продакшен.

Как я делаю это в TDD: не думаю о том как и где это будет хранится, доставаться и обрабатываться. Не пишем ни строчки реализации, а создаем сразу тест

{% highlight java %}

public class ProductAttributeTest {
  @Test
  public void test...
}
{% endhighlight %}

многоточие после имени метода test стоит не зря, тут я задумался: &laquo;а какое поведение вообще есть у атрибутов?&raquo;. 10 минут об этом размышляю и прихожу к выводу, что атрибуты ничего не умеют. А умеет продукт. Продукт содержит атрибуты, умеет их добавлять и удалять с себя. И атрибуты должны быть реализованы на продукте. 

Понимаю, что изначальная идея о реализации не верна. В случае классического &laquo;реализация-тесты&raquo; не возникло таких мыслей, написал реализацию, потом тесты для тестирования. Потом **мог бы** подумать о получившимся дизайне, но **не стал** бы.

Из этой истории я понял, что TDD заставляет думать о том, как должна работать доменная модель, а не как ее реализовать. Это позволяет выявлять ошибки дизайна модели до того, как модель появится. Как приятное дополнение к этому мы получим: тестируемый код, много легких тестов, рефакторинг как часть процесса разработки.

